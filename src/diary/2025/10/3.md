***
从前有一个小镇，镇上有红眼睛和蓝眼睛两种人。诡异的是，镇上的人只要确定了自己的眼睛是什么颜色，就会在第二天自动消失。因此，镇上没有镜子，大家也绝对不会互相点明对方眼睛的颜色。

有一天，镇上来了个红眼睛的外乡人。他并不了解这个小镇的奇异情况，毫无顾忌地在广场上说道：“呀，你们这里有些人眼睛颜色跟我一样欸。”

大家大惊，赶快制止了他继续说下去，并把他送走了。之后，为防止这种事情再发生，禁止了小镇的任何人员出入。

日子似乎又平静地过了下去。幸好处理及时，没有引起什么严重的事故

吗？

外乡人走后第50天，镇上所有红眼睛的人突然全都消失了。

问：镇上有多少红眼睛的人？
***
为了练手，我为这道题增加了**二阶段**

把红蓝两种眼睛拓展成`MAX_MARK`种标记,并且每个人身上有`MARKS_EACH_ONE`种标记，在确定自己所有标记之后才会在第二天消失。在第`n`天人们将会得知镇上有`n`标记的人

为了能练习文件操作，我决定以 *txt* 记录小镇每个人身上的标记，程序需读取文件并处理文本。

*txt* 格式：每行为一个人的标记(乱序)，以`,`分割不同标记

例：

```
1,2,4
2,1,3
3,1,2
```

8月构思好了这个题目，并用python写了个 *txt* 生成器

<details>
<summary>MarkedTown_Generator.py</summary>

```python
import os,random,sys
from itertools import count

MAX_TRIES = 10000
REPORT = 500
MAX_MARK = 10
MARKS_EACH_ONE = 3
POPULATION = 1000

tries = 0       
while True:
    tries += 1
    if tries%REPORT == 0:
        print(f'has tried for {tries} times')
    marks = '\n'.join(
        ','.join(map(str,random.sample(range(1, MAX_MARK + 1), MARKS_EACH_ONE)))
        for _ in range(POPULATION)
    )
    if tries == MAX_TRIES:
        print('generate不了一点 :(')
        sys.exit()
    if set(range(1, MAX_MARK + 1)) == set(int(b) for a in marks.split('\n') for b in a.split(',')):
        print(f'succeed in {tries} times')
        break


for n in count(1):
    filename = f"MarkedTown_{n:02d}.txt"
    if not os.path.exists(filename):
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(marks)
        break
```

</details>

也用Python写了解法

明天试试用C++和Rust来写写